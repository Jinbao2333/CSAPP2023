# lab1实验报告
## 10225501447 姜嘉祺
---
### 1.bitXor
要实现按位异或运算，即当两个位置上值的真值相反时，该位结果为1。不难发现，当x和y两者真值相同时，x & y和 ~x & ~y真值必然相反。而当x和y真值不同时，两者真值相同且为F，故利用这一性质，将两者取反后进行&操作，实现当真值相反时，将该位结果置为1。下面的真值表可以说明结果的正确性。

|x	|y	|~x	|~y	|~x & ~y	|x & y	|~(~x & ~y)	|~(x & y)	|~(~x & ~y) & ~(x & y)|
|---|---|---|---|---|---|---|---|---|
|0	|0	|1	|1	|1	|0	|0	|1	|0|
|0	|1	|1	|0	|0	|0	|1	|0	|1|
|1	|0	|0	|1	|0	|0	|1	|0	|1|
|1	|1	|0	|0	|0	|1	|1	|0	|0|

---
### 2.tmin
首先，左移运算符 << 用来将1向左移动31位，生成一个整数，其最高位为1，其余位为0。
该整数在二进制补码表示法下即为一个带符号整数类型的最小值，因为其最高位为1，表示负数，其余位为0，表示最小的负数。

---
### 3.isTmax
要实现判断给定的整数x是否为带符号整数类型的最大值，那么————
首先，将x加1，得到x+1。
将x+1再加x+1，得到2*(x+1)。当x为有符号整数最大值时，x+1的结果为最小值（就是负的最大值），而2*(x+1)的结果为0。
对2*(x+1)进行逻辑非操作，得到1，然后再次进行逻辑非操作，得到0。如果x不是最大值，则这里得到的值为1。
对x+1进行逻辑非操作，得到0，然后再次进行逻辑非操作，得到1。如果x不是最大值，则这里是0。
对1和0进行按位与操作，得到0。如果x是最大值，则这里得到的值为1。所以就实现了代码的功能。

---
### 4.allOddBits
要判断所有的奇数位是否都为1，就想保留x的所有奇数位，然后将偶数位清零。这个就用&操作，用0xAAAAAAAA（已经拆分了，报错……我知错了orz）来和x进行&，保留了x中奇数位。然后再将这个结果和0xAAAAAAAA本身进行按位异或操作。就不难得出结果了。（后面的就略去了~）

---
### 5.negate 
想要得到x的相反数，感觉要对补码等等的性质很了解哇。所以先对x按位取反，就是用~，然后加上1，就是得到了x的相反数的补码形式了。感觉就是概念要搞懂，不过多试几次也就出结果了 :P

---
### 6.isAsciiDigit 
（这道题的题干里就给出来了ASCII码有用的信息，不用去查，真好）
先将x减去ASCII码中0的值，就代表将x转化为十进制的值。然后-1，再和0x39（代表9）值相减，如果是十进制数字字符，那么此时这个值应该是非负数（这好像是数学问题）。然后对于0那端的判断也是同理，不再赘述。后面的过程就略去了。

---
### 7.conditional 
就是实现一个三目运算符。首先对x进行非操作，这样当x为T时，结果为0。然后进行按位取反，即将0和1互换。这里使用了一个小技巧：~1 + 1 的结果为 0，~0 + 1 的结果为1，因此可以将 ~1 + 1 视为“1”，将 ~0 + 1 视为“0”，从而实现 0 和 1 互换。对得到的结果与y进行按位与操作。如果 x 为真，则该操作的结果为 y，否则为 0。对 x 进行逻辑非操作，并将结果取反，得到x的布尔值。如果 x为真，那么该操作的结果为0。然后把结果与z进行按位与操作。如果x为真，结果为0，否则为z。将上一步和上一步得到的结果进行按位或操作，就可以得到最终的结果了。

---
### 8.isLessOrEqual  
先将x和y的符号搞出来，存入两个变量。然后再搞一个signZ，这可能有三种结果，0,1或者2，分别代表了x和y符号相同、x负y非负、x非负y负。然后计算y - x的值，并且将这个差值的符号位拎出来和之前的x和y符号情况比较，然后就可以得出结果了。

---
### 9.logicalNeg  
该实现的大致思路是利用补码表示中负数的符号位为1的特性，将非零整数转换为负数，0转换为0。然后通过右移和加1的方式将结果转换为0或1。（累了，实际上是来不及了）

---
### 10.howManyBits 
首先，将符号位取出到sign里。将x取反，并根据符号位进行按位与运算，得到一个数，其在x为正数时等于x，在x为负数时等于x的按位取反。这样处理是想让负数转换为对应的正数，以计算最小位数。接着依次判断x在高16位、高8位、高4位、高2位、高1位和最低位的值是否为1，如果是，则将其对应的位数保存在b16、b8、b4、b2、b1和b0中。对了，这里的!!运算符是将结果转换为布尔值的作用。然后将x向右移动 b16+b8+b4+b2+b1+b0位，这样可以丢掉除最高位和符号位以外的所有位。最后统统加起来，再加符号位，就是所求的最小位数。

---
### 11.floatScale2 
浮点数的题目。将传入的浮点数uf按位与上0x80000000，得到它的符号位，存入sign。然后将uf按位与上0x7f800000，得到它的指数部分exp。接着将uf按位与上0x007fffff，得到它的尾数部分frac。
如果exp等于0，说明uf是非规格化数（denormalized value），此时将frac左移一位即可，相当于将它乘以2的0次方。如果exp不等于0x7f800000且不等于0，说明uf是规格化数（normalized value），此时将exp加上0x00800000，相当于将它加上2的7次方，即将指数部分加1，实现将浮点数乘以2的1次方。如果exp等于0x7f800000，说明uf是正无穷或NaN，此时将frac置为0，以满足正无穷或NaN的表示方式。
最后，返回符号位、指数部分和尾数部分按位或的结果，即将浮点数的符号、指数和尾数部分合并起来返回。

---
### 12.floatFloat2Int 
又用到补码了……老样子，先从uf中提取出符号位、指数和尾数三个部分，然后进行判断，如果uf表示的是0或者小于1的非规格化浮点数，函数返回0；如果uf表示的数值超过了整型的范围，函数返回1<<31。接下来，将uf的尾数右移exp-127位，再进行补码转换，得到整数结果，最后将符号位与整数结果进行或运算，就得出结果了。

### 运行结果：
![运行结果截图](https://jupyterhub.shuishan.net.cn/user/10225501447/files/lab1/lab1sc.png "lab1sc")