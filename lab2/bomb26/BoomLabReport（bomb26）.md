Name: Jiaqi Jiang  ID: 10225501447

# phase_1

首先进入gdb，输入反汇编命令，得到以下的内容：

```objectivec
Dump of assembler code for function phase_1:
=> 0x0000555555556627 <+0>:     endbr64
   0x000055555555662b <+4>:     sub    $0x8,%rsp
   0x000055555555662f <+8>:     lea    0x1b1a(%rip),%rsi        # 0x555555558150
   0x0000555555556636 <+15>:    call   0x555555556b34 <strings_not_equal>
   0x000055555555663b <+20>:    test   %eax,%eax
   0x000055555555663d <+22>:    jne    0x555555556644 <phase_1+29>
   0x000055555555663f <+24>:    add    $0x8,%rsp
   0x0000555555556643 <+28>:    ret    
   0x0000555555556644 <+29>:    call   0x555555556e23 <explode_bomb>
   0x0000555555556649 <+34>:    jmp    0x55555555663f <phase_1+24>
End of assembler dump.
```
再结合调用的<strings_not_equal>函数，不难发现这是一个判断输入字符串是否与指定字符串相同的炸弹。
接着在gdb中查看指定字符串的值：

```clojure
(gdb) x/s 0x555555558150
0x555555558150: "Border relations with Canada have never been better."
```
输入答案，炸弹拆除了！（话说一开始就搞了我好久，算是来了个下马威hhh）

---
# phase_2

首先进行反汇编，得到：

```objectivec
Dump of assembler code for function phase_2:
   0x000055555555664b <+0>:     endbr64
   0x000055555555664f <+4>:     push   %rbp
   0x0000555555556650 <+5>:     push   %rbx
   0x0000555555556651 <+6>:     sub    $0x28,%rsp
   0x0000555555556655 <+10>:    mov    %fs:0x28,%rax
   0x000055555555665e <+19>:    mov    %rax,0x18(%rsp)
   0x0000555555556663 <+24>:    xor    %eax,%eax
   0x0000555555556665 <+26>:    mov    %rsp,%rsi
   0x0000555555556668 <+29>:    call   0x555555556e65 <read_six_numbers>
   0x000055555555666d <+34>:    cmpl   $0x0,(%rsp)
   0x0000555555556671 <+38>:    js     0x55555555667d <phase_2+50>
   0x0000555555556673 <+40>:    mov    %rsp,%rbp
   0x0000555555556676 <+43>:    mov    $0x1,%ebx
   0x000055555555667b <+48>:    jmp    0x555555556690 <phase_2+69>
   0x000055555555667d <+50>:    call   0x555555556e23 <explode_bomb>
   0x0000555555556682 <+55>:    jmp    0x555555556673 <phase_2+40>
   0x0000555555556684 <+57>:    add    $0x1,%ebx
   0x0000555555556687 <+60>:    add    $0x4,%rbp
   0x000055555555668b <+64>:    cmp    $0x6,%ebx
   0x000055555555668e <+67>:    je     0x5555555566a1 <phase_2+86>
   0x0000555555556690 <+69>:    mov    %ebx,%eax
   0x0000555555556692 <+71>:    add    0x0(%rbp),%eax
   0x0000555555556695 <+74>:    cmp    %eax,0x4(%rbp)
   0x0000555555556698 <+77>:    je     0x555555556684 <phase_2+57>
   0x000055555555669a <+79>:    call   0x555555556e23 <explode_bomb>
   0x000055555555669f <+84>:    jmp    0x555555556684 <phase_2+57>
   0x00005555555566a1 <+86>:    mov    0x18(%rsp),%rax
   0x00005555555566a6 <+91>:    sub    %fs:0x28,%rax
   0x00005555555566af <+100>:   jne    0x5555555566b8 <phase_2+109>
   0x00005555555566b1 <+102>:   add    $0x28,%rsp
   0x00005555555566b5 <+106>:   pop    %rbx
   0x00005555555566b6 <+107>:   pop    %rbp
   0x00005555555566b7 <+108>:   ret    
   0x00005555555566b8 <+109>:   call   0x555555556280 <__stack_chk_fail@plt>
End of assembler dump.
```
该程序首先接受一个六个数字的输入，然后首位必须为1。
进一步分析代码，可以发现，这段代码实际上是将输入的六个数字和循环中计算而得的六个数字比较。如果全部相等，就可以成功拆除炸弹。

而看这个循环中对数字做了什么——首先第一位数字是1，然后每经历一次循环，依次加上1,2,3,4,5。也就是1,2,4,7,11,16。

在gdb中输入这几个数，成功地拆除炸弹。


---
# phase_3

```objectivec
Dump of assembler code for function phase_3:
   0x00005555555566bd <+0>:     endbr64
   0x00005555555566c1 <+4>:     sub    $0x18,%rsp
   0x00005555555566c5 <+8>:     mov    %fs:0x28,%rax
   0x00005555555566ce <+17>:    mov    %rax,0x8(%rsp)
   0x00005555555566d3 <+22>:    xor    %eax,%eax
   0x00005555555566d5 <+24>:    lea    0x4(%rsp),%rcx
   0x00005555555566da <+29>:    mov    %rsp,%rdx
   0x00005555555566dd <+32>:    lea    0x1d61(%rip),%rsi        # 0x555555558445
   0x00005555555566e4 <+39>:    call   0x555555556330 <__isoc99_sscanf@plt>
   0x00005555555566e9 <+44>:    cmp    $0x1,%eax
   0x00005555555566ec <+47>:    jle    0x555555556708 <phase_3+75>
   0x00005555555566ee <+49>:    cmpl   $0x7,(%rsp)
   0x00005555555566f2 <+53>:    ja     0x555555556759 <phase_3+156>
   0x00005555555566f4 <+55>:    mov    (%rsp),%eax
   0x00005555555566f7 <+58>:    lea    0x1ac2(%rip),%rdx        # 0x5555555581c0
   0x00005555555566fe <+65>:    movslq (%rdx,%rax,4),%rax
   0x0000555555556702 <+69>:    add    %rdx,%rax
   0x0000555555556705 <+72>:    notrack jmp *%rax
   0x0000555555556708 <+75>:    call   0x555555556e23 <explode_bomb>
   0x000055555555670d <+80>:    jmp    0x5555555566ee <phase_3+49>
   0x000055555555670f <+82>:    mov    $0x17e,%eax
   0x0000555555556714 <+87>:    cmp    %eax,0x4(%rsp)
   0x0000555555556718 <+91>:    jne    0x55555555676c <phase_3+175>
   0x000055555555671a <+93>:    mov    0x8(%rsp),%rax
   0x000055555555671f <+98>:    sub    %fs:0x28,%rax
   0x0000555555556728 <+107>:   jne    0x555555556773 <phase_3+182>
   0x000055555555672a <+109>:   add    $0x18,%rsp
   0x000055555555672e <+113>:   ret    
   0x000055555555672f <+114>:   mov    $0x2b6,%eax
   0x0000555555556734 <+119>:   jmp    0x555555556714 <phase_3+87>
   0x0000555555556736 <+121>:   mov    $0x142,%eax
   0x000055555555673b <+126>:   jmp    0x555555556714 <phase_3+87>
   0x000055555555673d <+128>:   mov    $0x28a,%eax
   0x0000555555556742 <+133>:   jmp    0x555555556714 <phase_3+87>
   0x0000555555556744 <+135>:   mov    $0x61,%eax
   0x0000555555556749 <+140>:   jmp    0x555555556714 <phase_3+87>
   0x000055555555674b <+142>:   mov    $0x100,%eax
   0x0000555555556750 <+147>:   jmp    0x555555556714 <phase_3+87>
   0x0000555555556752 <+149>:   mov    $0x2dd,%eax
   0x0000555555556757 <+154>:   jmp    0x555555556714 <phase_3+87>
   0x0000555555556759 <+156>:   call   0x555555556e23 <explode_bomb>
   0x000055555555675e <+161>:   mov    $0x0,%eax
   0x0000555555556763 <+166>:   jmp    0x555555556714 <phase_3+87>
   0x0000555555556765 <+168>:   mov    $0x34c,%eax
   0x000055555555676a <+173>:   jmp    0x555555556714 <phase_3+87>
   0x000055555555676c <+175>:   call   0x555555556e23 <explode_bomb>
   0x0000555555556771 <+180>:   jmp    0x55555555671a <phase_3+93>
   0x0000555555556773 <+182>:   call   0x555555556280 <__stack_chk_fail@plt>
End of assembler dump.
```
通过+32处可以查看到，输入是两个整数：
```clojure
(gdb) x/s 0x555555558445
0x555555558445: "%d %d"
```
接着+44和+49两处表明输入的参数个数要大于1，小于等于7，同时ja为无符号跳转，则参数还大于0，因此得出第一个参数的范围[0,7]。接下来是一系列间接跳转，也就是通过第一个参数不同的值跳转到不同的位置。代码中一连串的jmp和mov也可以证明。跳转后将值存入eax，并与第二个输入的数字进行比较。就是个switch的实现。
我偷懒了，进行尝试可以得到2 694是其中的一个解，输入之，拆除～


---
# phase_4

还是先disassemble一下：

```objectivec
Dump of assembler code for function phase_4:
   0x00005555555567b3 <+0>:     endbr64
   0x00005555555567b7 <+4>:     sub    $0x18,%rsp
   0x00005555555567bb <+8>:     mov    %fs:0x28,%rax
   0x00005555555567c4 <+17>:    mov    %rax,0x8(%rsp)
   0x00005555555567c9 <+22>:    xor    %eax,%eax
   0x00005555555567cb <+24>:    mov    %rsp,%rcx
   0x00005555555567ce <+27>:    lea    0x4(%rsp),%rdx
   0x00005555555567d3 <+32>:    lea    0x1c6b(%rip),%rsi        # 0x555555558445
   0x00005555555567da <+39>:    call   0x555555556330 <__isoc99_sscanf@plt>
   0x00005555555567df <+44>:    cmp    $0x2,%eax
   0x00005555555567e2 <+47>:    jne    0x5555555567ef <phase_4+60>
   0x00005555555567e4 <+49>:    mov    (%rsp),%eax
   0x00005555555567e7 <+52>:    sub    $0x2,%eax
   0x00005555555567ea <+55>:    cmp    $0x2,%eax
   0x00005555555567ed <+58>:    jbe    0x5555555567f4 <phase_4+65>
   0x00005555555567ef <+60>:    call   0x555555556e23 <explode_bomb>
   0x00005555555567f4 <+65>:    mov    (%rsp),%esi
   0x00005555555567f7 <+68>:    mov    $0x8,%edi
   0x00005555555567fc <+73>:    call   0x555555556778 <func4>
   0x0000555555556801 <+78>:    cmp    %eax,0x4(%rsp)
   0x0000555555556805 <+82>:    jne    0x55555555681c <phase_4+105>
   0x0000555555556807 <+84>:    mov    0x8(%rsp),%rax
   0x000055555555680c <+89>:    sub    %fs:0x28,%rax
   0x0000555555556815 <+98>:    jne    0x555555556823 <phase_4+112>
   0x0000555555556817 <+100>:   add    $0x18,%rsp
   0x000055555555681b <+104>:   ret    
   0x000055555555681c <+105>:   call   0x555555556e23 <explode_bomb>
   0x0000555555556821 <+110>:   jmp    0x555555556807 <phase_4+84>
   0x0000555555556823 <+112>:   call   0x555555556280 <__stack_chk_fail@plt>
End of assembler dump.
```
这个感觉有点棘手了。
首先还是可以确定需要输入俩整型数据。而且第二个数字必须大于等于2小于等于4。但是发现这个炸弹问题中还调用了一个func4函数，不妨将这个函数拿出来反汇编一下看一下里边的东西：

```objectivec
Dump of assembler code for function func4:
   0x0000000000002778 <+0>:     endbr64 
   0x000000000000277c <+4>:     mov    $0x0,%eax
   0x0000000000002781 <+9>:     test   %edi,%edi
   0x0000000000002783 <+11>:    jle    0x27b2 <func4+58>
   0x0000000000002785 <+13>:    push   %r12
   0x0000000000002787 <+15>:    push   %rbp
   0x0000000000002788 <+16>:    push   %rbx
   0x0000000000002789 <+17>:    mov    %edi,%ebx
   0x000000000000278b <+19>:    mov    %esi,%ebp
   0x000000000000278d <+21>:    mov    %esi,%eax
   0x000000000000278f <+23>:    cmp    $0x1,%edi
   0x0000000000002792 <+26>:    je     0x27ad <func4+53>
   0x0000000000002794 <+28>:    lea    -0x1(%rdi),%edi
   0x0000000000002797 <+31>:    call   0x2778 <func4>
   0x000000000000279c <+36>:    lea    (%rax,%rbp,1),%r12d
   0x00000000000027a0 <+40>:    lea    -0x2(%rbx),%edi
   0x00000000000027a3 <+43>:    mov    %ebp,%esi
   0x00000000000027a5 <+45>:    call   0x2778 <func4>
   0x00000000000027aa <+50>:    add    %r12d,%eax
   0x00000000000027ad <+53>:    pop    %rbx
   0x00000000000027ae <+54>:    pop    %rbp
   0x00000000000027af <+55>:    pop    %r12
   0x00000000000027b1 <+57>:    ret    
   0x00000000000027b2 <+58>:    ret    
End of assembler dump.
```
发现这个函数传入了两个整数，并且有递归调用的过程。通过分析，可以将类似等价的C语言代码模拟出来：
```c++
int func4(int edi, int esi) {
    int eax = 0;
    if (edi > 0) {
        int r12d, ebp, ebx;
        ebx = edi;
        ebp = esi;
        eax = esi;
        if (edi == 1) return eax;
        edi--;
        eax = func4(edi, esi);
        r12d = eax + ebp;
        edi = ebx - 2;
        esi = ebp;
        eax = func4(edi, esi);
        eax += r12d;
    }
    return eax;
}
```
用递推式得出来就可以是：
$$func4(x, y)=\begin{cases}    func4(x-2,y)+func4(x-1,y)+y, &\text{if x ≤ 2} \\    x, &\text{if x = 0,1}\end{cases}$$

~~（离散数学后遗症）~~

又发现在phase_4中，传入func4的第一个参数值（也就是edi里的）是8。继续观察，可以发现要求输入的第一个值与func4的返回值相同。

总结一下就是：

* 依次输入A、B（允许在2-4之间）；
* A = func4(8, B)；
由此可以得出，输入以下三组的内容应该都是可以拆弹的：

>108 2
>162 3
>216 4

---
# phase_5

上反汇编代码：

```objectivec
Dump of assembler code for function phase_5:
   0x0000555555556828 <+0>:     endbr64 
   0x000055555555682c <+4>:     sub    $0x18,%rsp
   0x0000555555556830 <+8>:     mov    %fs:0x28,%rax
   0x0000555555556839 <+17>:    mov    %rax,0x8(%rsp)
   0x000055555555683e <+22>:    xor    %eax,%eax
   0x0000555555556840 <+24>:    lea    0x4(%rsp),%rcx
   0x0000555555556845 <+29>:    mov    %rsp,%rdx
   0x0000555555556848 <+32>:    lea    0x1bf6(%rip),%rsi        # 0x555555558445
   0x000055555555684f <+39>:    call   0x555555556330 <__isoc99_sscanf@plt>
   0x0000555555556854 <+44>:    cmp    $0x1,%eax
   0x0000555555556857 <+47>:    jle    0x5555555568b3 <phase_5+139>
   0x0000555555556859 <+49>:    mov    (%rsp),%eax
   0x000055555555685c <+52>:    and    $0xf,%eax
   0x000055555555685f <+55>:    mov    %eax,(%rsp)
   0x0000555555556862 <+58>:    cmp    $0xf,%eax
   0x0000555555556865 <+61>:    je     0x555555556899 <phase_5+113>
   0x0000555555556867 <+63>:    mov    $0x0,%ecx
   0x000055555555686c <+68>:    mov    $0x0,%edx
   0x0000555555556871 <+73>:    lea    0x1968(%rip),%rsi        # 0x5555555581e0 <array.0>
   0x0000555555556878 <+80>:    add    $0x1,%edx
   0x000055555555687b <+83>:    cltq   
   0x000055555555687d <+85>:    mov    (%rsi,%rax,4),%eax
   0x0000555555556880 <+88>:    add    %eax,%ecx
   0x0000555555556882 <+90>:    cmp    $0xf,%eax
   0x0000555555556885 <+93>:    jne    0x555555556878 <phase_5+80>
   0x0000555555556887 <+95>:    movl   $0xf,(%rsp)
   0x000055555555688e <+102>:   cmp    $0xf,%edx
   0x0000555555556891 <+105>:   jne    0x555555556899 <phase_5+113>
   0x0000555555556893 <+107>:   cmp    %ecx,0x4(%rsp)
   0x0000555555556897 <+111>:   je     0x55555555689e <phase_5+118>
   0x0000555555556899 <+113>:   call   0x555555556e23 <explode_bomb>
   0x000055555555689e <+118>:   mov    0x8(%rsp),%rax
   0x00005555555568a3 <+123>:   sub    %fs:0x28,%rax
   0x00005555555568ac <+132>:   jne    0x5555555568ba <phase_5+146>
   0x00005555555568ae <+134>:   add    $0x18,%rsp
   0x00005555555568b2 <+138>:   ret    
   0x00005555555568b3 <+139>:   call   0x555555556e23 <explode_bomb>
   0x00005555555568b8 <+144>:   jmp    0x555555556859 <phase_5+49>
   0x00005555555568ba <+146>:   call   0x555555556280 <__stack_chk_fail@plt>
End of assembler dump.
```
通过查看0x555555558445处，可以看到输入依旧要求两个整型数据。且第一个数字不能为15。
发现+73处有个数组，查看这里的值，发现刚好是一个16个元素的数组，各个数字如下：

```clojure
(gdb) p *0x5555555581e0@16
$1 = {10, 2, 14, 7, 8, 12, 15, 11, 0, 4, 1, 13, 3, 9, 6, 5}
```
进一步分析代码，可以得知接下来进行的是数组累加求和。且整个循环共15次。
这个程序的要求就是输入两个整型数据A、B，使得循环15次到数组的A时，求和的值为B。可以计算前15项的和为115，此时循环到5。所以最终尝试输入5 115，成功拆解炸弹！


---
# phase_6

~~（啊……令人头大的链表！今天刚学就学以致用了……家人们谁懂啊）~~

怀着抵触的心理，先disassemble一下吧：

```objectivec
Dump of assembler code for function phase_6:
   0x00005555555568bf <+0>:     endbr64 
   0x00005555555568c3 <+4>:     push   %r14
   0x00005555555568c5 <+6>:     push   %r13
   0x00005555555568c7 <+8>:     push   %r12
   0x00005555555568c9 <+10>:    push   %rbp
   0x00005555555568ca <+11>:    push   %rbx
   0x00005555555568cb <+12>:    sub    $0x60,%rsp
   0x00005555555568cf <+16>:    mov    %fs:0x28,%rax
   0x00005555555568d8 <+25>:    mov    %rax,0x58(%rsp)
   0x00005555555568dd <+30>:    xor    %eax,%eax
   0x00005555555568df <+32>:    mov    %rsp,%r13
   0x00005555555568e2 <+35>:    mov    %r13,%rsi
   0x00005555555568e5 <+38>:    call   0x555555556e65 <read_six_numbers>
   0x00005555555568ea <+43>:    mov    $0x1,%r14d
   0x00005555555568f0 <+49>:    mov    %rsp,%r12
   0x00005555555568f3 <+52>:    jmp    0x55555555691d <phase_6+94>
   0x00005555555568f5 <+54>:    call   0x555555556e23 <explode_bomb>
   0x00005555555568fa <+59>:    jmp    0x55555555692c <phase_6+109>
   0x00005555555568fc <+61>:    add    $0x1,%rbx
   0x0000555555556900 <+65>:    cmp    $0x5,%ebx
   0x0000555555556903 <+68>:    jg     0x555555556915 <phase_6+86>
   0x0000555555556905 <+70>:    mov    (%r12,%rbx,4),%eax
   0x0000555555556909 <+74>:    cmp    %eax,0x0(%rbp)
   0x000055555555690c <+77>:    jne    0x5555555568fc <phase_6+61>
   0x000055555555690e <+79>:    call   0x555555556e23 <explode_bomb>
   0x0000555555556913 <+84>:    jmp    0x5555555568fc <phase_6+61>
   0x0000555555556915 <+86>:    add    $0x1,%r14
   0x0000555555556919 <+90>:    add    $0x4,%r13
   0x000055555555691d <+94>:    mov    %r13,%rbp
   0x0000555555556920 <+97>:    mov    0x0(%r13),%eax
   0x0000555555556924 <+101>:   sub    $0x1,%eax
   0x0000555555556927 <+104>:   cmp    $0x5,%eax
   0x000055555555692a <+107>:   ja     0x5555555568f5 <phase_6+54>
   0x000055555555692c <+109>:   cmp    $0x5,%r14d
   0x0000555555556930 <+113>:   jg     0x555555556937 <phase_6+120>
   0x0000555555556932 <+115>:   mov    %r14,%rbx
   0x0000555555556935 <+118>:   jmp    0x555555556905 <phase_6+70>
   0x0000555555556937 <+120>:   mov    $0x0,%esi
   0x000055555555693c <+125>:   mov    (%rsp,%rsi,4),%ecx
   0x000055555555693f <+128>:   mov    $0x1,%eax
   0x0000555555556944 <+133>:   lea    0x48e5(%rip),%rdx        # 0x55555555b230 <node1>
```
且慢，太长了碍眼，就放这么多吧。
首先，害怕归害怕，最基本的输入得看一下嘛。还是输入六个数字，而且都要小于等于6。

大致的功能，在查阅了网上一大堆有关链表的知识和杂七杂八的东西之后，大概了解了这个东西实现的功能，就是将原来六个值按顺序排列一下，光说不做怎么行呢？那就动手试试看吧，万一瞎猫碰到死耗子呢。

然后欣喜地发现，截进来的这段代码中最后一行里有个贴心的<node1>，这就出现链表结点了，赶紧根据它顺藤摸瓜：

```clojure
(gdb) x/20xw 0x55555555b230
0x55555555b230 <node1>: 0x00000261      0x00000001      0x5555b240      0x00005555
0x55555555b240 <node2>: 0x000001d4      0x00000002      0x5555b250      0x00005555
0x55555555b250 <node3>: 0x000000f8      0x00000003      0x5555b260      0x00005555
0x55555555b260 <node4>: 0x00000272      0x00000004      0x5555b270      0x00005555
0x55555555b270 <node5>: 0x00000154      0x00000005      0x5555b110      0x00005555
(gdb) x/4xw 0x55555555b110
0x55555555b110 <node6>: 0x0000012d      0x00000006      0x00000000      0x00000000
```
看第一列就得到了六个结点的值，不过是十六进制的，问题不大。按照大小进行排序，按照编号应该依次是4、1、2、5、6、3。再看下面的代码，发现是将相应的结点赋地址+赋值，最后进行一个循环判断，判断条件是：
```clojure
0x00005555555569ba <+251>:   cmp    %eax,(%rbx)
0x00005555555569bc <+253>:   jge    0x5555555569ab <phase_6+236>
```
也就是前一个结点的值必须大于等于后一个结点的值，这里不存在等于的情况。也就是刚刚排的顺序应该就是解密的关键。输入进去，果不其然，看看这行优美的文字！
```plain
Congratulations! You've defused the bomb!
Your instructor has been notified and will verify your solution.
```

---
为什么还有隐藏炸弹！为什么还有人已经卷完了隐藏炸弹！算了，先放空一下脑子吧，切换一下频道，毕竟已经拆弹拆得头晕眼花了……

